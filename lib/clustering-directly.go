// PTRA: Patient Trajectory Analysis Library
// Copyright (c) 2022 imec vzw.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version, and Additional Terms
// (see below).

// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Affero General Public License for more details.

// You should have received a copy of the GNU Affero General Public
// License and Additional Terms along with this program. If not, see
// <https://github.com/ExaScience/ptra/blob/master/LICENSE.txt>.

package lib

import (
	"encoding/csv"
	"fmt"
	"github.com/imec-int/ptra/lib/utils"
	"io"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strconv"
)

// jaccardTrajectory computes the Jaccard similarity coefficient for two given trajectories.
func jaccardTrajectory(t1, t2 *Trajectory) float64 {
	// intersect t1 and t2
	n := 0
	for _, d1 := range t1.Diagnoses {
		if slices.Contains(t2.Diagnoses, d1) {
			n++
		}
	}
	nt1 := len(t1.Diagnoses)
	nt2 := len(t2.Diagnoses)
	return float64(n) / (float64(nt1) + float64(nt2) - float64(n))
}

// SzymkiewiczSimpsonTrajectory computes the Szymkiewicz-Simpson similarity coefficient for two given trajectories.
func SzymkiewiczSimpsonTrajectory(t1, t2 *Trajectory) float64 {
	n := 0
	for _, d1 := range t1.Diagnoses {
		if slices.Contains(t2.Diagnoses, d1) {
			n++
		}
	}
	nt1 := len(t1.Diagnoses)
	nt2 := len(t2.Diagnoses)
	return float64(n) / float64(utils.MinInt(nt1, nt2))
}

// SorensenDiceTrajectory computes the SorensenDice similarity coefficient for two given trajectories.
func SorensenDiceTrajectory(t1, t2 *Trajectory) float64 {
	n := 0
	for _, d1 := range t1.Diagnoses {
		if slices.Contains(t2.Diagnoses, d1) {
			n++
		}
	}
	nt1 := len(t1.Diagnoses)
	nt2 := len(t2.Diagnoses)
	return float64(2*n) / (float64(nt1 + nt2))
}

// convertTrajectoriesToAbcFormat compute the jaccard between each trajectory and writes out the result to file.
// Streaming algorithm to avoid pressure on memory.
func convertTrajectoriesToAbcFormat(exp *Experiment, name string) {
	//create output file
	file, err := os.Create(name)
	if err != nil {
		log.Panic(err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Panic(err)
		}
	}()
	// compute the jacard index for the trajectories
	for i, t1 := range exp.Trajectories {
		for j := i + 1; j < len(exp.Trajectories); j++ {
			t2 := exp.Trajectories[j]
			coeff := jaccardTrajectory(t1, t2)
			fmt.Fprintf(file, "%d\t%d\t%f\n", i, j, coeff)
		}
	}
}

// ClusterTrajectories performs clustering of the trajectories that have been calculated for a given experiment.
// It does a pairwise comparison of all trajectories by calculating the jaccard similarity coefficients. Subsequently,
// MCL clustering is used to group the trajectories by jaccard similarity into clusters.
func ClusterTrajectories(exp *Experiment, granularities []int, path string) error {
	fmt.Println("Clustering trajectories directly with MCL")
	// convert trajectories to abc format for the Mcl tool
	dirName := fmt.Sprintf("%s-clusters-directly/", exp.Name)
	workingDir := filepath.Join(path, dirName) + string(filepath.Separator)
	fmt.Println("Working path becomes: ", workingDir)
	derr := os.MkdirAll(workingDir, 0777)
	if derr != nil {
		return derr
	}

	// change working dir because Mcl program dumps files into working dir
	cdErr := os.Chdir(workingDir)
	if cdErr != nil {
		return cdErr
	}

	abcFileName := fmt.Sprintf("%s%s.abc", workingDir, exp.Name)
	convertTrajectoriesToAbcFormat(exp, abcFileName)
	tabFileName := fmt.Sprintf("%s%s.tab", workingDir, exp.Name)
	mciFileName := fmt.Sprintf("%s%s.mci", workingDir, exp.Name)
	mcxLoadErr := McxLoadAbc(abcFileName, tabFileName, mciFileName)
	if mcxLoadErr != nil {
		return mcxLoadErr
	}

	// run the clustering with different granularities
	for _, gran := range granularities {
		mclErr := Mcl(mciFileName, gran)
		if mclErr != nil {
			return mclErr
		}
	}

	// convert the clustering to readable format
	clusterFileName := fmt.Sprintf("out.%s.mci", exp.Name)
	outFileName := fmt.Sprintf("dump.%s.mci", exp.Name)
	for _, gran := range granularities {
		mcxDumpErr := McxDump(clusterFileName, tabFileName, outFileName, gran)
		if mcxDumpErr != nil {
			return mcxDumpErr
		}
	}

	// convert the clustering generated by Mcl tool to gml format
	for _, gran := range granularities {
		dumpFileName := fmt.Sprintf("%s.I%d", outFileName, gran)
		convertToGml(exp, dumpFileName, fmt.Sprintf("%s.trajectories.gml", dumpFileName))
		PrintClusteredTrajectoriesToFile(exp, fmt.Sprintf("%s.clustered.trajectories.tab", dumpFileName))
		PrintClustersToCSVFiles(exp, fmt.Sprintf("%s.clustered.patients.csv", dumpFileName),
			fmt.Sprintf("%s.clustered.clusters.csv", dumpFileName))
	}

	return nil
}

// collectTrajectoriesFromCluster looks up trajectories associated with a given list of trajectory ids and assigns
// each of these to a specific cluster id. It returns the list of trajectory objects.
func collectTrajectoriesFromCluster(exp *Experiment, ids []int, clusterID int) []*Trajectory {
	ts := []*Trajectory{}
	for _, id := range ids {
		// assign cluster label to trajectory
		exp.Trajectories[id].Cluster = clusterID
		ts = append(ts, exp.Trajectories[id])
	}
	return ts
}

// convertToGml converts MCL cluster output - a file with for each cluster id a list of
// trajectory ids - to a GML output file that plots the trajectories as graphs. Each cluster is plotted as a separate
// subgraph, with diagnosis codes used as nodes and trajectory transitions used as edges. The edges are annotated with
// the relatitive risk score (RR) and number of patients associated with the diagnosis pair that the edge represents.
func convertToGml(exp *Experiment, input, output string) {
	file, err := os.Open(input)
	if err != nil {
		panic(err)
	}
	ofile, oerr := os.Create(output)
	if oerr != nil {
		panic(oerr)
	}
	defer func() {
		if err := file.Close(); err != nil {
			panic(err)
		}
		if oerr := ofile.Close(); oerr != nil {
			panic(oerr)
		}
	}()

	// trajectories to assign to clusters
	nofClusters := 0

	// parse file
	reader := csv.NewReader(file)
	reader.Comma = '\t'
	reader.FieldsPerRecord = -1
	reader.LazyQuotes = true
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(err)
		}
		// collect codes in the cluster
		var codes []int
		for _, rcode := range record {
			code, err := strconv.Atoi(rcode)
			if err != nil {
				panic(err)
			}
			codes = append(codes, code)
		}
		// print the trajectories in the cluster
		collected := collectTrajectoriesFromCluster(exp, codes, nofClusters)
		nofClusters++
		// print this cluster
		// print header
		fmt.Fprintf(ofile, "graph [\n\tdirected 1\n\tmultigraph 1\n")
		nodePrinted := map[int]bool{}

		// TODO: use printTrajectory(t, exp, ofile) to print the trajectories
		//  right now I don't have the means to test the output of this function

		// print nodes
		for _, t := range collected {
			for _, node := range t.Diagnoses {
				if _, ok := nodePrinted[node]; !ok {
					icd10 := exp.Icd10Map[node]
					fmt.Fprintf(ofile, fmt.Sprintf("\tnode [\n\t\tid %d\n\t\tlabel\"%s\"\n\t]\n", node, icd10.Name))
					nodePrinted[node] = true
				}
			}
		}
		// print edges
		edgePrinted := make([][]bool, exp.NofDiagnosisCodes)
		for i, _ := range edgePrinted {
			edgePrinted[i] = make([]bool, exp.NofDiagnosisCodes)
		}
		for _, t := range collected {
			d1 := t.Diagnoses[0]
			tlen := len(t.Diagnoses)
			for i := 1; i < len(t.Diagnoses); i++ {
				d2 := t.Diagnoses[i]
				if !edgePrinted[d1][d2] {
					edgePrinted[d1][d2] = true
					n := t.PatientNumbers[i-1]
					RR := strconv.FormatFloat(exp.DxDRR[d1][d2], 'f', 2, 64)
					fmt.Fprintf(ofile, fmt.Sprintf("\tedge [\n\t\ttid %d\n\t\ttlen %d\n\t\ttidx %d\n\t\tsource %d\n\t\ttarget %d\n\t\tpatients %d\n\t\tRR \"%s\"\n\t]\n", t.ID, tlen, i, d1, d2, n, RR))
				}
				d1 = d2
			}
		}
		fmt.Fprintf(ofile, "]\n")
	}
	fmt.Println("For ", output)
	fmt.Println("Collected ", nofClusters, " clusters")
}

// percentMalesFemales computes for a given list of patients the percentage of males and females wrt to the total number
// of males and females in the experiment.
func percentMalesFemales(exp *Experiment, ps []*Patient) (float64, float64) {
	m := 0
	f := 0
	for _, p := range ps {
		if p.Sex == Male {
			m++
		} else {
			f++
		}
	}
	return (100.0 / float64(exp.MCtr)) * float64(m), (100.0 / float64(exp.FCtr)) * float64((f))
}

// getDiagnosisDate returns the concrete diagnosis date for a given pair of diagnosis ids.
func getDiagnosisDate(p *Patient, d1, d2 int) DiagnosisDate {
	d1idx := -1
	d2idx := -1
	for i, d := range p.Diagnoses {
		if d.DID == d1 {
			d1idx = i
			continue
		}
		if d.DID == d2 && d1idx != -1 {
			d2idx = i
		}
	}
	return p.Diagnoses[d2idx].Date
}

// percentEOI computes percent of patients that have their event of interest at the time of the transition of disease
// d1 -> d2
func percentEOI(exp *Experiment, ps []*Patient, d1, d2 int) float64 {
	eoictr := 0
	for _, p := range ps {
		d := getDiagnosisDate(p, d1, d2)
		if p.EOIDate != nil && DiagnosisDateSmallerThan(*p.EOIDate, d) {
			eoictr++
		}
	}
	return (100.0 / float64(len(ps))) * float64(eoictr)
}

func transitionInformation(exp *Experiment, t *Trajectory, i, d1, d2 int) (string, string, string) {
	rr := strconv.FormatFloat(exp.DxDRR[d1][d2], 'f', 2, 64)
	m, f := percentMalesFemales(exp, t.Patients[i])
	mfratio := strconv.FormatFloat(m/f, 'f', 2, 64)
	eoi := strconv.FormatFloat(percentEOI(exp, t.Patients[i], d1, d2), 'f', 0, 64)
	return rr, mfratio, eoi
}
